[[{"l":"Byte Engine"}],[{"l":"Setup","p":["To start using Byte for your projects, follow the next guides.","They will take you through:","Setting up your environment","Creating your first project","Deploying your project"]}],[{"l":"Environment setup","p":["Byte depends on a few external tools to work properly. You will need to install them before you can start using Byte."]},{"l":"Vulkan SDK","p":["Byte uses Vulkan for rendering. You will need to install the Vulkan SDK to be able to compile and run Byte."]},{"i":"rustup","l":"Rust(up)","p":["Byte is written in Rust. You will need to install Rust to be able to compile and run Byte."]},{"l":"Optional"},{"l":"Mold","p":["Mold is fast linker. It is not required to run Byte, but if you are writing native code, it is recommended."]},{"l":"RenderDoc","p":["RenderDoc is a graphics debugger. It is not required to run Byte, but it is useful for debugging. Byte has an integration with RenderDoc to facilitate debugging."]}],[{"l":"Installation","p":["To install Byte, run the following command:"]}],[{"l":"Sample Project","p":["The best way to learn is through examples. So, let's create a sample project to see how to use the framework.","We will be working on a simple game where the player can shoot at a gallery to score points."]}],[{"l":"Input","p":["If our game is going to be any good we probably want our player to be able to move."]}],[{"l":"Project configuration","p":["Our application needs a place to start.","Create a file called main.rs.","Then add the following code:","This will create a new application with the name \"Gallery Shooter\". The application manages all utilities we will need to run our game.","Let's think about what we need to make our game.","We need a player, targets, weapon.","So let's define them.","We a need a place to put them."]}],[{"l":"Design","p":["In this section we explain the design of the different parts of the engine."]}],[{"l":"Render Design","p":["Keep this in mind when reading this document:"]},{"l":"Render system","p":["The render system provides easy to use abstractions over the render backend. It allows you to create textures, buffers, shaders, etc. and then use them to render things. It abstracts details like staging buffers, memory allocation, etc. away from the user.","Each render system is backed by a render backend. The render backend is responsible for creating the actual resources and executing the commands. This render backend can be chosen when creating the render system (e.g. Vulkan, OpenGL, DirectX, etc.)"]},{"l":"Render pipeline","p":["A render pipeline is a collection of ..."]},{"l":"Render domain","p":["A render domain is collection of renderables that all live in the same space and we'd want to be managed by a common cohesive rendering technique."]},{"l":"Render model","p":["A render model is an implementation of a render domain.","Say we have a render domain RenderWorld we could have a render model RenderWorldVisibilityBuffer, RenderWorldDefered and RenderWorldForward. Each one would render the world using different techniques."]}]]